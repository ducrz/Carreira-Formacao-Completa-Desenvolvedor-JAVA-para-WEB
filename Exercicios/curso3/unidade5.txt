UNIDADE 5: Novidades Java 8

Introdução às Expressões Lambda

Cálculo Lambda
É um modelo que oferece uma maneira muito formal de descrever o cálculo
de uma função. Foi projetado por Alonzo Church em 1930.
Uma abstração lambda é um tipo de expressão que denota uma função:
(λx.+x1), onde “λ” determina que existe uma função.

Atualmente, as linguagens C++, C#, JavaScript, Python, Ruby, Jruby, Scala, Clojure, já oferecem suporte ao uso de expressões lambdas!

O Java tem evoluido para aumentar seu poder de expressão, incorporando novos recursos: Collections API , Generics, Annotations, Lambdas, Stream
API, entre outros.


Java e o Paradigma Funcional

Até a versão 7 Java pode ser definida como uma linguagem imperativa Orientada a Objetos. A partir da versão 8, Java também passa a incorporar
funcionalidades do paradigma funcional, quando adota em sua sintaxe o cálculo Lambda!

Método até o Java 7

class Conta {
...                       OBJETO      TIPO
public boolean transfere (Conta conta,float valor){

Método a partir do Java 8

class Conta {
...                                              Lambda
public boolean transfere (Conta conta,float valor, λ){

Expressões Lambda
A implementação da JSR 335: Lambda Expressions for the JavaTM Programming Language provocou uma das maiores atualizações
em termos de código fonte, tanto na JVM como no JDK (compilador e bibliotecas).

Para se ter uma idéia, ao se enumerar as novas classes dos pacotes java.util e java.util.concurrent que dão suporte à JSR 335 no JDK 8,
chega-se ao expressivo número de 283 classes. Se também for somado as classes dos novos pacotes java.util.function e java.util.stream, chega-se a
um total de 896 classes a mais no JDK 8 em relação ao JDK 7, como pode ser visto na Tabela abaixo.

A principal novidade do Java 8 é o suporte às Expressões Lambda.
A sua adoção pela tecnologia Java era muito aguardada, principalmente pelo suporte a elas no Framework Collections.

O que são?

Expressões Lambda são um novo recurso da linguagem Java para implementar de maneira simples o cálculo lambda.
No Java 8 o lambda representa uma função anônima. Esta é definida em uma interface (Functional Interface) que possui apenas um único método abstrato!
Com o uso das Expressões Lambda é possível a construção de um código mais conciso, pois evita a criação de classes anônimas de apenas um método.


CLASSES ANÔNIMAS
São classes que não possuem nome, não tem construtor e só são utilizadas dentro de um bloco de código para oferecer alguma funcionalidade.

btnNewButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {
...
} });

Isso implica em não ser possível termos uma variável do tipo dessas classes, uma vez que não sabemos qual o seu tipo, ou melhor, qual o nome de seu tipo.

Elas são utilizadas geralmente quando se quer uma classe para implementar determinada interface, porém, só é utilizada em um contexto muito restrito.

CLASSES ANÔNIMAS X LAMBDAS


btnNewButton.addActionListener(new ActionListener() {
public void actionPerformed(ActionEvent event) {
...
} });

||
λ

btnNewButton.addActionListener(event-> {...});

É importante ressaltar que o lambda não é a mesma coisa que uma classe interna anônima, visto que esta pode possuir muitos métodos e o lambda apenas um!

Primeiro Lambda JAVA

public class LambdaApp {
public static void main(String[] args) {
List<Integer>integers = Arrays.asList(1, 2, 3, 4, 5);
//Expressão Lambda
integers.forEach(x->System.out.println(x));
}
}

O método forEach(...) aceita a função anônima como entrada e chama a referida função para cada elemento da lista.

A função anônima é representada pela expressão abaixo, onde x é o seu parâmetro do tipo inteiro.

X -> System.out.println(x);

Ciclo de Vida Lambda JAVA

São dois os estágios no Ciclo de Vida Lambda Java:

1) Converter a expressão lambda para uma função

x -> System.out.print(x);

public static void generatedNameOfLambdaFunction(Integer X){
	System.out.println(x);
}
2) Executar a função chamada

Segundo Lambda JAVA

public class LambdaApp2 {
	public static void main(String[] args) {
		List<Integer>integers = Arrays.asList(1, 2, 3, 4, 5);
		integers.forEach(x ->{
		x = x + 10;
		System.out.println(x);
	});
}
}

• Neste código o valor de x é incrementado em 10!

Terceiro Lambda JAVA

As variáveis podem ser lidas ‘fora’ do escopo das Expressões Lambdas.

public class LambdaApp3 {
	public static void main(String[] args) {
		int numero = 10;
		List<Integer>integers = Arrays.asList(1, 2, 3, 4, 5);
		integers.forEach(x ->{
		x = x + numero;
		System.out.println(x);
	});
}
}
Contudo, essas variáveis não podem ser modificadas.

public static void main(String[] args) {
...
numero = 20; //ERRO DE COMPILAÇÃO
x = x + numero;
...

Quarto Lambda JAVA

Diferentemente das variáveis locais, o acesso aos atributos de objeto e de classe podem ser lidos e modificados.

public class LambdaApp4 {
static int numero;
int somatorio;
public static void main(String[] args) {
List<Integer>integers = Arrays.asList(1, 2, 3, 4, 5);
LambdaApp2 app = new LambdaApp2();
integers.forEach(x ->{
numero = 10;
x = x + numero;
app.somatorio = app.somatorio + x;
System.out.println(x);
});
System.out.println(app.somatorio);
}
}

Quinto Lambda JAVA

public class LambdaApp5 {
public static void main(String[] args) {
List<Integer>integers = Arrays.asList(1, 2, 3, 4, 5);
integers.forEach(x ->{
int y = x/2;
System.out.println(y);
});
}
}
Neste código é criado uma variável local y!

Sexto Lambda JAVA

public class LambdaApp6 {
public static void main(String[] args) {
List<Integer>integers = Arrays.asList(1, 2, 3, 4, 5);
integers.forEach((Integer x) ->{
x = x + 10;
System.out.println(x);
});
}
}

Neste código é passado um parâmetro do tipo Integer!

Exercícios

1) Escreva as classes LambdaApp, LambdaApp2, LambdaApp3, LambdaApp4, LambdaApp5 e LambdaApp6.
2) Altere o código LambdaApp e inclua a variável var, conforme imagem abaixo. Pergunta-se: por que o erro abaixo? Como corrigi-lo?


List<Integer> integers = Arrays.asList(1,2,3,4,5,);

int var =1;
integers.fordEach(x -> {
	var++;
Error: Local variable defined in a enclosing scope must be final or effectively final
	System.out.println(x);
	});
	
Resposta: LambdaAppV2 onde foi declarada a variável dentro da Expressão Lambda.
	
Sintaxe Lambda

REGRAS DE SINTAXE DAS EXPRESSÕES LAMBDAS
A declaração dos tipos de parâmetros é opcional;

() -> System.out.println(this)

A utilização de parêntesis () em volta do parâmetro é opcional se houver apenas um parâmetro;

(String str) -> System.out.println(str)
str -> System.out.println(str)

A utilização de colchetes {} é opcional, a menos que sejam definidos múltiplas instruções;

(String s1, String s2) -> {return s2.length()
s1.length();}
(s1, s2) -> s2.length() - s1.length()

O uso da palavra return é opcional se houver uma simples expressão que retorne um valor.

CLASSES ANÔNIMAS → SEM EXPRESSÃO LAMBDA

interface IMatematica{
	public int somar(int a, int b);
	public int subtrair(int a, int b);
	public int multiplicar(int a, int b);
	public int dividir(int a, int b);
}

CLASSES ANÔNIMAS → SEM EXPRESSÃO LAMBDA

public class Calculadora{
public static void main(String[] args) {
IMatematica anonimo = new IMatematica() {
//objeto tipo anônimo que implementa IMatematica
public int somar(int a, int b){return a+b;}
public int subtrair(int a, int b){return a-b;}
public int multiplicar(int a, int b){return a*b;}
public int dividir(int a, int b){return a/b;}
};
System.out.println("anônimo: " + anonimo.getClass());
System.out.println(“=> " + anonimo.somar(5,5));
System.out.println(“=> " + anonimo.subtrair(6,4));
System.out.println(“=> " + anonimo.multiplicar(3,4));
System.out.println(“=> " + anonimo.dividir(10,2));
}
}

CLASSES ANÔNIMAS → SEM EXPRESSÃO LAMBDA

Após a execução do código, têm-se as seguintes saídas:

anônimo: class Calculadora$1
=> 10 => 2
=> 12 => 5

O Java nomeia as classes anônimas como se fossem classes internas da classe onde foram declaradas. O nome individual de cada classe anônima é, na verdade, apenas um inteiro.

CLASSES ANÔNIMAS → EXPRESSÃO LAMBDA

Criar uma Interface Funcional com o método int operacao(...)

@FunctionalInterface
interface IMath
{
int operacao(int a, int b);
}

Criar uma Expressão Lambda que instancie a interface A.

Sintaxe Padrão:

parâmetros -> corpo

CLASSES ANÔNIMAS → EXPRESSÃO LAMBDA

public class Calculadorav2 {
public static void main(String[] args) {
Calculadorav2 ex = new Calculadorav2();
IMath somar = (a,b)-> a+b; //Expressão Lambda
IMath subtrair = (a,b)-> a-b; //Expressão Lambda
IMath multiplicar = (a,b)-> a*b; //Expressão Lambda
IMath dividir = (a,b)-> a/b; //Expressão Lambda
System.out.println(ex.execOperacao(5, 5, somar));
System.out.println(ex.execOperacao(6, 4, subtrair));
System.out.println(ex.execOperacao(3, 4, multiplicar));
System.out.println(ex.execOperacao(10, 2, dividir));
}
public int execOperacao(int a, int b, IMath op) {
return op.operacao(a, b);
}
}

Exercícios

1) Modifique as classes Calculadora e Calculadorav2, bem como as interfaces IMatematica e IMath para incluir os métodos exponenciação e radiciação.

2) Transformar o código abaixo para deixar de utilizar classe anônima e passar a utilizar EL.

Validador<String> validadorCEP = new Validador<String>(){
	public boolean valida(String valor){
		return valor.matches("[0-9]{5}-[0-9]{3}");
	}
};

interface Validador<T>{
	boolean valida(T t);
}


Interfaces Funcionais

Interfaces funcionais são o "coração" do recurso de Lambda. O Lambda por si só não existe, mas sim as Expressões Lambda quando associadas a uma interface funcional.

Pode-se marcar "explicitamente" uma interface como funcional, bastando utilizar a anotação @FuncionalInterface.

@FunctionalInterface
interface IMath {
	int operacao(int a, int b);
}

No exemplo acima, sem o uso dessa anotação, o Java entenderia que a interface IMath é "implicitamente" Funcional.

Como já foi citado anteriormente, foi criado no Java 8 o pacote java.util.function para a definição de um conjunto de Interfaces Funcionais (43) a serem utilizadas pelo desenvolvedor Java.

PACOTE JAVA.UTIL.FUNCTION
As principais Interfaces Funcionais estão listadas abaixo:
 Predicate <T>
 Supplier <T>
 Function <T,R>
 Consumer <T>
 Comparator <T>
 BiFunction
 BiConsumer
 IntConsumer
 IntFunction <R>
 IntPredicate
 IntSupplier
 
 A seguir, as principais Interfaces Funcionais são apresentadas.

PREDICATE<T>
É uma Interface Funcional que recebe um valor T e faz um teste qualquer no objeto recebido como parâmetro. Retorna ‘true’ ou ‘false’.

Predicate<String> predicate = (s) -> s.length() > 0;
predicate.test("foo"); // true
predicate.negate().test("foo"); // false

SUPLLIER<T>
É uma Interface Funcional que não recebe nenhum valor e retorna um resultado T.
Supplier<Perssoa> pessoaSupplier = new Pessoa();
pessoaSupplier.get(); // novo objeto Pessoa

FUNCTION<T,R>
É uma Interface Funcional que recebe um valor T e retorna um resultado R.

Function<String, String> atr = (name)-> {return "@"+name;};
Function<String, Integer> leng = (name)-> name.length();
void m() {
int y = 3;
Function<Integer,Integer> f = x -> x + y;
f.apply(2);
}

CONSUMER<T>
É uma Interface Funcional que recebe um valor T e imprime um valor.

Consumer<Pessoa> greeter = (p) -> System.out.println
("Ola," + p.nome);
greeter.accept(new Pessoa("Antonio", "Sampaio"));

COMPARATOR<T>

É uma Interface Funcional que recebe um valor T e retorna um resultado R.

Comparator<Pessoa> comparator = (p1, p2) ->
p1.nome.compareTo(p2.nome);
Pessoa p1 = new Pessoa("João", “Pedro");
Pessoa p2 = new Pessoa("Alice", "Wonder");
comparator.compare(p1, p2); // > 0
comparator.reversed().compare(p1, p2); // < 0

Exercício

1) Compile o código abaixo e identifique qual foi o erro gerado.


@FunctionalInterface
interface Validador<T>{
	boolean valida(T t);
	boolean outroMetodo(T t);

}
Resposta: só pode ter um método abstrato.

Manutenção da Compatibilidade

Qualquer interface com um método é considerada pelo Java 8 como Interface Funcional!

No Java 8, os lambdas irão trabalhar com as bibliotecas mais antigas que usam as interfaces funcionais, sem a necessidade de recompilá-las ou modificá-las.

INTERFACE RUNNABLE
Pode-se afirmar que toda interface Java que possui apenas um método abstrato pode ser instanciada como um código lambda! Isso vale até mesmo para as interfaces antigas, pré-Java 8, como por exemplo a interface Runnable:

public interface Runnable {
	public abstract void run();
}

Nova interface Runnable no Java 8:

@FunctionalInterface
public interface Runnable{
	void run();
}

INTERFACE RUNNABLE

Implementação de Runnable sem Lambda

public class ThreadApp {
public static void main(String[] args) {
//objeto tipo anônimo que implementa Runnable
Runnable r = new Runnable(){
public void run(){
for (int i = 0; i <= 1000; i++){
System.out.println(i);
}
}
};
new Thread(r).start();
}
}

INTERFACE RUNNABLE

Implementação de Runnable com Lambda

public class ThreadAppLambda {
public static void main(String[] args) {
//criação de um Lambda
Runnable r = () ->
{
for (int i = 0; i <= 1000; i++)
System.out.println(i);
};
//criando uma Thread passando como argumento um Lambda
new Thread(r).start(); }
}

Exercícios
1) Implementar as classes ThreadApp e ThreadAppLambda.
2) Quais as diferenças observadas nessas duas classes?
Código mais limpo e elegante utilizando Lambda.
